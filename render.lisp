
(in-package :ulubis)

(defclass texture-gl ()
  ((width :accessor width :initarg :width :initform 0)
   (height :accessor height :initarg :height :initform 0)
   (cepl-texture :accessor cepl-texture :initarg :cepl-texture :initform 0)))

(defun create-texture (surface)
  (when (not (pointer-eq (->buffer surface) (null-pointer)))
    (let* ((buffer (->buffer surface))
	   (shm-buffer (wl-shm-buffer-get buffer))
	   (w (wl-shm-buffer-get-width shm-buffer))
	   (h (wl-shm-buffer-get-height shm-buffer))
	   (stride (wl-shm-buffer-get-stride shm-buffer))
	   (array (make-c-array-from-pointer
		   (list w h)
		   :uint8-vec4 
		   (wl-shm-buffer-get-data shm-buffer))))
      (setf (width surface) w)
      (setf (height surface) h)
      (when (and (texture surface) (cepl-texture (texture surface)))
	(free (cepl-texture (texture surface))))
      (setf (texture surface) (make-instance 'texture-gl
					     :width w
					     :height h
					     :cepl-texture
					     (make-texture
					      array
					      :element-type :rgba8)))
      ;; Copy pixels from shared-memory buffer to SDL texture
      (wl-buffer-send-release buffer)
      (setf (->buffer surface) (null-pointer)))))

#|
(defmacro with-surface ((vertex-stream tex mode surface &key (z 0) (scale 1.0)) &body body)
  (let ((x (gensym "x"))
	(y (gensym "y"))
	(texture (gensym "texture"))
	(width (gensym "width"))
	(height (gensym "height"))
	(array (gensym "array")))
    `(let* ((,x (x ,surface))
	    (,y (y ,surface))
	    (,texture (texture ,surface))
	    (,width (width ,texture))
	    (,height (height ,texture))
	    (,array (make-gpu-array (list (list (v! ,x ,y ,z)
						(v! 0 0))
					  (list (v! (+ ,x (round (* ,scale ,width))) ,y ,z)
						(v! 1 0))
					  (list (v! (+ ,x (round (* ,scale ,width))) (+ ,y (round (* ,scale ,height))) ,z)
						(v! 1 1))
					  (list (v! (+ ,x (round (* ,scale ,width))) (+ ,y (round (* ,scale ,height))) ,z)
						(v! 1 1))
					  (list (v! ,x (+ ,y (round (* ,scale ,height))) ,z)
						     (v! 0 1))
					  (list (v! ,x ,y ,z)
						(v! 0 0)))
				    :dimensions 6 :element-type 'g-pt))
	    (,vertex-stream (make-buffer-stream ,array :retain-arrays t))
	    (,tex (cepl-texture ,texture)))
       (with-blending (blending-parameters ,mode)
	 ,@body)
       (free ,vertex-stream)
       (free ,array)

       (when (->frame-callback ,surface)
		 (wl-callback-send-done (->frame-callback ,surface) (get-milliseconds))
		 (wl-resource-destroy (->frame-callback ,surface))
		 (setf (->frame-callback ,surface) nil)))))
|#

(defmacro with-surface ((vertex-stream tex mode surface &key (z 0) (scale 1.0)) &body body)
  (let ((x (gensym "x"))
	(y (gensym "y"))
	(texture (gensym "texture"))
	(width (gensym "width"))
	(height (gensym "height"))
	(array (gensym "array")))
    `(let* ((,x (x ,surface))
	    (,y (y ,surface))
	    (,texture (texture ,surface))
	    (,width (width ,texture))
	    (,height (height ,texture))
	    (,array (make-gpu-array (list (list (v! 0 0 ,z)
						(v! 0 0))
					  (list (v! ,width 0 ,z)
						(v! 1 0))
					  (list (v! ,width ,height ,z)
						(v! 1 1))
					  (list (v! ,width ,height ,z)
						(v! 1 1))
					  (list (v! 0 ,height ,z)
						(v! 0 1))
					  (list (v! 0 0 ,z)
						(v! 0 0)))
				    :dimensions 6 :element-type 'g-pt))
	    (,vertex-stream (make-buffer-stream ,array :retain-arrays t))
	    (,tex (cepl-texture ,texture)))
       (with-blending (blending-parameters ,mode)
	 ,@body)
       (free ,vertex-stream)
       (free ,array)

       (when (->frame-callback ,surface)
		 (wl-callback-send-done (->frame-callback ,surface) (get-milliseconds))
		 (wl-resource-destroy (->frame-callback ,surface))
		 (setf (->frame-callback ,surface) nil)))))


(defun ortho (left right bottom top near far)
  (let ((m (m4:identity)))
    (setf (m4:melm m 0 0) (/ 2.0 (- right left)))
    (setf (m4:melm m 1 1) (/ 2.0 (- top bottom)))
    (setf (m4:melm m 2 2) (/ -2.0 (- far near)))
    (setf (m4:melm m 0 3) (coerce (- (/ (+ right left) (- right left))) 'float))
    (setf (m4:melm m 1 3) (coerce (- (/ (+ top bottom) (- top bottom))) 'float))
    (setf (m4:melm m 2 3) (coerce (- (/ (+ far near) (- far near))) 'float))
    m))

(defun-g default-vertex-shader ((vert g-pt) &uniform (ortho :mat4) (surface-scale :mat4) (surface-translate :mat4))
  (values (* ortho surface-translate surface-scale (v! (pos vert) 1))
	  (:smooth (tex vert))))

(defun-g default-fragment-shader ((tex-coord :vec2) &uniform (texture :sampler-2d) (alpha :float))
  (v! (s~ (texture texture tex-coord) :xyz)
      (* alpha (s~ (texture texture tex-coord) :w))))

(defun-g cursor-vertex-shader ((vert :vec3) &uniform (ortho :mat4))
  (values (* ortho (v! vert 1))
	  (v! 1 1 1 1)))

(defun-g cursor-fragment-shader ((color :vec4))
  color)

(def-g-> cursor-pipeline ()
  #'cursor-vertex-shader #'cursor-fragment-shader)

(defun draw-cursor (x y ortho)
  (let* ((array (make-gpu-array
		 (list (v! x y 0)
		       (v! x (+ y 32) 0)
		       (v! (+ x 16) (+ y 24) 0))
		 :dimensions 3 :element-type :vec3))
	 (vertex-stream (make-buffer-stream array :retain-arrays t)))
    (map-g #'cursor-pipeline vertex-stream
	   :ortho ortho)
    (free vertex-stream)
    (free array)
    (setf (render-needed *compositor*) t)))
